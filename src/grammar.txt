name ::= [^ \t\n(){},;_]+                    // variable name

type ::= name                                // name of type, data, or alias
type ::= type -> type                        // function type

mtype ::= ':' type                           // mandatory type annotation
otype ::= (mtype)?                           // optional type annotation

cons ::= name                                // type constructor, no values
cons ::= name '(' type (',' type)* ')'       // tagged values

lit ::= <all inbuilt literals>               // char, bool, int, float
                                             // list, string, tuple, unit

lit ::= name                                 // data constructor no values
lit ::= name '(' simp (',' simp)* ')'        // data constructor

inst ::= 'data' name '=' (cons)('|' cons)*   // ADT
alias ::= 'type' name '=' name               // type alias

expr ::= let ptrn '=' simp (';'|'\n') expr   // binding
expr ::= simp                                // idk man

simp ::= fn([name otype ',']+) otype simp    // function/closure
simp ::= 'match' simp [ptrn ':' simp]+       // pattern matching
simp ::= name '(' simp (',' simp)* ')'       // function call
simp ::= name                                // variable
simp ::= lit                                 // inline literal into simp

simp ::= { expr }                            // block

====

data Maybe = Some(Int) | None

let div = fn(a, b)
    match b:
        0: None
        _: Some(a / b)

let gcd = fn(a, b)
    match b
        0 : a
        _ : gcd(b, a % b)

gcd(10, 5)